import jwt from 'jsonwebtoken';

export default (req, res, next) => {
  // Получаем токен из заголовка авторизации, удаляя префикс 'Bearer' (если есть)
  const token = (req.headers.authorization || '').replace(/Bearer\s?/, '');

  // Если токен существует
  if (token) {
    try {
      // Проверяем и декодируем токен, используя секретный ключ 'secret123'
      const decoded = jwt.verify(token, 'secret123');

      // Добавляем ID пользователя в объект `req` для использования в последующих обработчиках
      req.userId = decoded._id;

      // Переходим к следующему обработчику
      next();
    } catch (e) {
      // Если произошла ошибка при верификации токена
      return res.status(403).json({
        message: 'Нет доступа', // Возвращаем статус 403 (Запрещено) и сообщение 'Нет доступа'
      });
    }
  } else {
    // Если токен не найден в заголовке запроса
    return res.status(403).json({
      message: 'Нет доступа', // Возвращаем статус 403 и сообщение 'Нет доступа'
    });
  }
};

//Объяснение:
// Получение токена: Код берет заголовок authorization из запроса, удаляя префикс "Bearer" (если он присутствует), чтобы получить сам токен.
// Проверка токена: Если токен найден, код пытается его верифицировать с помощью jwt.verify(), используя секретный ключ 'secret123'.
// Обработка успешной верификации: Если токен успешно верифицирован, код декодирует его и извлекает идентификатор пользователя decoded._id. Затем этот ID добавляется к объекту req (например, req.userId), чтобы другие части приложения могли использовать эту информацию.
// Переключение к следующему обработчику: Если верификация прошла успешно, вызывается next(), чтобы перейти к следующему обработчику.
// Обработка ошибок: Если токен недействителен или отсутствует, код возвращает статус 403 (Forbidden) и сообщение "Нет доступа".
// Этот middleware полезен для защиты маршрутов, к которым должны иметь доступ только аутентифицированные пользователи. Если токен отсутствует или недействителен, доступ запрещается, и возвращается статус 403.